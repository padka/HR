# Надёжность и устойчивость (наблюдения)

## Текущее состояние (as-is)
- Статусы валидируются через `status_service.update_candidate_status`; откат статуса — no-op (мягкая защита от ретраев).
- Побочные эффекты (создание слотов, рассылки бота) выполняются вне транзакции смены статуса → возможны расхождения при сбое/гонке.
- Уникальные ограничения на слоты для кандидата не enforced на уровне схемы (риск двойной брони при параллельных запросах).
- Фоновые напоминания и уведомления завязаны на Redis/бот-стейте; при отсутствии Redis поведение зависит от вызова (часть тестов прогоняется без Redis).

## Риски
- **Двойные клики/гонки:** нет `SELECT ... FOR UPDATE` и уникальных индексов на активные слоты → потенциальные дубли.
- **Атомарность:** смена статуса и сайд-эффекты выполняются раздельно → могут остаться в промежуточном состоянии.
- **Stalled waiting:** переход в `stalled_waiting_slot` не автоматизирован (нет cron/worker).
- **Наблюдаемость:** нет структурированных логов/метрик на переходы статусов (сложно расследовать инциденты).
- **Redis недоступен:** не везде описана ожидаемая деградация; возможны скрытые ошибки при планировании напоминаний.

## Предложения (дальнейшие шаги)
- MUST: покрыть матрицу переходов и идемпотентность тестами (unit + integration) — начато в `tests/test_status_service_transitions.py`.
- SHOULD: добавить уникальный индекс на активные слоты кандидата (`candidate_tg_id`, `purpose`, `status in (pending, booked, confirmed)`), оборачивать назначение ОД и смену статуса в транзакцию.
- SHOULD: структурированные логи на каждую смену статуса (candidate_id, from, to, actor, request_id); счётчик метрик успешных/failed переходов.
- COULD: документировать/реализовать стратегию при отсутствии Redis (fail-fast vs. fallback), добавить лидер-лочинг для фоновых напоминаний.
