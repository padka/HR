# Performance Results (local) — 2026-02-17

Цель цикла 2: перейти от “синтетических 50k RPS” к life-like профилям нагрузки, формально зафиксировать knee-of-curve по SLO и сделать **доказуемые DB-оптимизации на cache-miss путях** для:
- `/api/profile`
- `/api/dashboard/summary`
- `/api/dashboard/incoming`
- `/api/calendar/events`

Ограничения: публичные URL/контракты/авторизация не менялись.

## Окружение

- host: local ноутбук
- server: `uvicorn` single process
- DB/Redis: `docker compose` (`postgres` + `redis_notifications` + `redis_cache`)
- bot: отключен (`BOT_ENABLED=0`)
- метрики: `METRICS_ENABLED=1`, `PERF_DIAGNOSTIC_HEADERS=1`
- DB профайлер (sampled): `DB_PROFILE_ENABLED=1`, `DB_PROFILE_SAMPLE_RATE=0.2`

### Профили нагрузки (life-like)

Скрипты: `scripts/loadtest_profiles/*`
- read-heavy: `scripts/loadtest_profiles/profiles/read_heavy.profile`
- mixed: `scripts/loadtest_profiles/profiles/mixed.profile`
- write-heavy (controlled): `scripts/loadtest_profiles/profiles/write_heavy.profile` (требует seeded данных)

### Knee-of-curve (SLO критерии)

Knee = первый step, где выполняется хотя бы одно:
- `error_rate > 0.5%`
- `p95 > 500ms` или `p99 > 1500ms` на критичных маршрутах
- `db_pool_acquire p95 > 50ms` (только при достаточном числе сэмплов)

Источник: `scripts/loadtest_profiles/analyze_step.py`

## Результаты: life-like (cache ON)

### Read-heavy (capacity)

- Артефакты: `.local/loadtest/profiles/read_heavy_20260217_094811/capacity/*`
- Knee: total=800 rps, stable=400 rps (`knee.json`)

### Mixed (capacity)

- Артефакты: `.local/loadtest/profiles/mixed_20260217_100005/capacity/*`
- Knee: total=400 rps (`knee.json`)
- Примечание: в этом профиле knee в основном диктуется “тяжёлыми” списками (например `/api/candidates*`) и контенцией пула.

## Результаты: DB cache-miss пути (PERF_CACHE_BYPASS=1)

Важно: этот режим нужен, чтобы *принудительно* оценить DB стоимость, когда кэша нет (например cold start / expiry / деградации).

### Read-heavy (capacity, cache-miss)

Baseline:
- Артефакты: `.local/loadtest/profiles/read_heavy_20260217_102806/capacity/*`
- Knee: total=100 rps, stable=50 rps

After DB fixes:
- Артефакты: `.local/loadtest/profiles/read_heavy_cachemiss_opt1_20260217_104516/capacity/*`
- Knee: total=100 rps, stable=50 rps
- При этом pool-acquire p95 на step=100 заметно снизился (с ~250ms до ~100ms на `/api/profile` и `/api/dashboard/summary`).

### Read-heavy (steady 5m @ total=50 rps, cache-miss) — до/после

Baseline (5 минут):
- Артефакты: `.local/loadtest/profiles/read_heavy_cachemiss_baseline_20260217_102931/total_50/*`
- SQL профиль: `.local/perf/sql_profile_baseline.json`

After (5 минут):
- Артефакты: `.local/loadtest/profiles/read_heavy_cachemiss_opt1_steady_20260217_104630/total_50/*`
- SQL профиль: `.local/perf/sql_profile_opt1.json`

#### HTTP latency (hist delta, success only)

| route | p95 before | p99 before | p95 after | p99 after |
|---|---:|---:|---:|---:|
| `/api/profile` | 100ms | 250ms | 50ms | 100ms |
| `/api/dashboard/summary` | 100ms | 250ms | 100ms | 250ms |
| `/api/dashboard/incoming` | 100ms | 250ms | 50ms | 100ms |
| `/api/calendar/events` | 100ms | 250ms | 100ms | 100ms |

Источник: `step.json` в директориях steady-run.

#### DB time per request (hist delta, success only)

| route | p95 before | p99 before | p95 after | p99 after |
|---|---:|---:|---:|---:|
| `/api/profile` | 50ms | 100ms | 25ms | 50ms |
| `/api/dashboard/summary` | 25ms | 50ms | 25ms | 50ms |
| `/api/dashboard/incoming` | 25ms | 25ms | 25ms | 50ms |
| `/api/calendar/events` | 25ms | 25ms | 25ms | 25ms |

Примечание: `db_queries_per_request` в этом стенде низкий для `/api/dashboard/incoming` и `/api/calendar/events` из-за малого числа подходящих сущностей в DB (не все ветки запроса выполняются). Для более “живого” контента используйте сидирование (см. `docs/performance/loadtesting.md`).

## Bottlenecks и фиксы (симптом → причина → доказательство → фикс → эффект)

### 1) `/api/profile`: тяжёлый payload + лишние загрузки ORM

Симптом:
- на cache-miss профиле `/api/profile` доминировал tail latency и pool acquire under load.

Причина:
- лишние ORM загрузки (`selectinload`) там, где используются только несколько колонок;
- дублирующий запрос на recruiter/cities внутри `/api/profile` (кроме `_profile_snapshot`).

Доказательство:
- baseline SQL fingerprint: `SELECT slots.id, slots.recruiter_id, ...` (полный слот) + subquery counts по full ORM rows, топ по total_ms.
- артефакты SQL профиля: `.local/perf/sql_profile_baseline.json`

Фикс:
- `_profile_snapshot()` переключён на column-projection (без `selectinload`) для slot lists + planner + upcoming slots;
- убран дублирующий DB поход для recruiter payload — данные берём из `_profile_snapshot()`.

Эффект:
- `/api/profile` p99 (read-heavy steady, cache-miss) улучшился: `250ms → 100ms`
- DB time p95: `50ms → 25ms`
- pool acquire p95 на `/api/profile` заметно снизился.

### 2) `/api/calendar/events`: меньше roundtrips за счёт join + проекции колонок

Симптом:
- лишние roundtrips (slots + selectinload recruiter + selectinload city + candidates + resources).

Фикс:
- slot query переписан на `JOIN Recruiter` + `OUTER JOIN City` + выбор нужных колонок;
- candidates/resources также выбираются проекцией колонок.

Эффект:
- меньше DB roundtrips и меньше payload per query; видно в SQL fingerprints:
  - baseline: `SELECT slots.id, slots.recruiter_id, slots.city_id, ...` (полный слот)
  - after: `SELECT slots.id, slots.start_utc, ... recruiters..., cities...` (только нужные поля)

### 3) `/api/dashboard/summary` и waiting counts: “select only ids” в count subqueries

Фикс:
- под `COUNT()` используются subquery только по `id`, без full ORM select.

Эффект:
- снизился суммарный DB time на cache-miss профиле, особенно на больших таблицах.

## Изменения в коде (ключевые)

- `/Users/mikhail/Projects/recruitsmart_admin/backend/apps/admin_ui/routers/api.py`
  - оптимизация `_profile_snapshot()` (проекция колонок, меньше ORM, убран дублирующий recruiter payload)
- `/Users/mikhail/Projects/recruitsmart_admin/backend/apps/admin_ui/services/dashboard.py`
  - `dashboard_counts()` и `get_waiting_candidates()` уменьшили DB payload (проекции/`id`-only counts)
- `/Users/mikhail/Projects/recruitsmart_admin/backend/apps/admin_ui/services/calendar_events.py`
  - join+projection вместо `selectinload` для slots/recruiter/city + облегчённые выборки кандидатов/ресурсов
- `/Users/mikhail/Projects/recruitsmart_admin/scripts/loadtest_profiles/analyze_step.py`
  - добавлены step-local p50/p95/p99 для `http_db_queries_per_request` и `http_db_query_time_seconds`

## Что дальше (perf backlog)

1) Добавить/использовать сидирование perf данных (waiting candidates + slots + messages + AIOutput), чтобы `/api/dashboard/incoming` и `/api/calendar/events` проходили “полные” ветки на стенде.
2) Mixed profile: отдельно профилировать `/api/candidates*` (это текущий доминирующий bottleneck), убрать N+1/лишние join.
3) Индексы: на реальных прод-объёмах проверить необходимость `(users.candidate_status, users.status_changed_at)` и `(slots.start_utc)` для admin calendar view.

